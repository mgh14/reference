CMD reference:

- bash:
	- arguments:
		- last argument (from last command): !$
		- nth argument (from last command): !:n
			- e.g. !:2
		- all n arguments: !:n-$
			- e.g. !:3-$ for everything after the second word
		- last arg of n commands ago: !-n:$
			- e.g. !-4:$ for the last arg four commands ago
		- strip filename off of folder: !$:h
			- e.g. cd /etc/docker fails, then cd !$:h goes to /etc
		- nth arg of current line: !#:n
			- e.g. echo a b c !#:2 yields 'echo a b c b'

	- find:
		- execute command for each result: find /path/to/start -type f -name "*.plist" -exec sed -i -e 's/SEARCH/REPLACE/g' \;
			- another example: find . -name "*.jar" -exec echo {} \;
				- The {} portion of this command represents the found filename, I believe
				- Note that the semicolon after -exec needs to be escaped
		- delete all found files: find . -name "*.txt" -delete

	- if:
		if [ ! -z "$MYVAR1" ] && [ ! -z "$MYVAR2"]; then
		<command1>
		elif
		<command2>
		elif
		<command3>
		else
		<command4>
		fi
	
		if [ ! -z "$MYVAR1" ] && [ "$ENABLED" == "true" ]; then echo "yep"; else echo "no"; fi

	- for loop: 
		for i in $(cat ~/Desktop/apps.txt | xargs);
		# for i in cat man tail
		do
		<command>, e.g. echo $i
		done
		- also:
			for (( i=1; i<=5; i++ ))
			do
				<command(s)>
			done

	- GREP:
	- extended regexp, -E
		- (look for ');' at the end of each line): grep -E ");$" file.txt 
	- show line numbers: -n
		grep -n "abc" file.txt
	- count instances: -c
		grep -c "abc" file.txt
	- include/exclude file: --include or --exclude
		grep --exclude "*.sql" "abc" file.sql
		- include/exclude directory: --include-dir --exclude-dir
			- e.g. grep --exclude-dir={dir1,dir2,dir3} 
		- NOTE: excludes TAKE PRECIDENCE OVER INCLUDES!!!
		- https://stackoverflow.com/questions/6565471/how-can-i-exclude-directories-from-grep-r
	- Don't search devices, FIFOs, sockets: -D skip
		grep -R -D skip "abc" /
	- Don't print filename: -h
	- MULTIPLE PATTERNS!!! -e
		grep -e "^abc.+" -e "^otherpattern.+" file.txt
		- for multiple NOTs, use -ve for each:
			grep -E -ve ";$" -ve "uigznaosy" -ve "--" -ve "^\s*$" -ve "^ALTER TABLE ONLY" -ve "\s+at org\.springframework" dev-core-db-dump-2-sep-2021.sql
		- Positive match uses of -e function as OR's, not AND's:
			grep -E -e "--" -e "^\s*$" -m 10 dev-core-db-dump-2-sep-2021.sql | grep -E -e "-- Dumped" -e "-- PostgreSQL database dump"
				- this returns instances of lines with only ONE of the above final grep's -e pattern matched
	- Ignore binary files: -I
	- List only the names of files not containing selected lines: -L
	- List files with matches, only searching until first instance INSIDE THE FILE is found: -l 
		- (lowercase L)
		- i.e. still lists multiple files, in other words list every file that has at least one match
	- Max count/number of matches: -m
	- Only show matching part of line: -o 
	- Run silent, i.e. nonexistent or unreadable files ignored (messages suppressed): -s
	- Line regexp, Only input lines selected against an entire fixed string or regular expression are considered to be matching lines: -x
	- The expression is searched for as a word (as if surrounded by `[[:<:]]' and `[[:>:]]'; see re_format(7)): -w
	- Prints a zero-byte after the file name: --null

	- copy file from user1 to user2 (user2 has elevated privileges):
		- login as user1
		- sudo su - user2
		- <find file, do stuff with it, whatever>
		- chmod 777 <file>
		- mv <file> /tmp
		- exit
		- (still logged in as user1): cp /tmp/<file> ~/
		- log back in as user2 and rm /tmp/<file>

	- redirect all out to file: 2>&1
		- append (as opposed to redirect/overwrite): >>
			E.g.: cat file1.txt >> file2.txt
	- xargs parse using comma as end of line, then echo each arg: xargs -E ',' -n1 echo
		- note: -E might just be the mac os cmd, for linux it might be -d
		- Execute 'mv' for each file found: find ./ -name '<name pattern here>' -exec <comand here> \;
		- e.g. find ./ -name '*article*' -exec mv {}  ../backup  \;
			- note: {} represents a found filename
		- OR find ./ -name '*article*' | xargs -I '{}' mv {} ../backup
			- e.g. ls | find . -name "*.json" | xargs -I '{}' mv "{}-e" "{}"
	- do-while loop: 
		while true; do
			<command(s)>
			[[ <condition ]] | break 
		done

		- examples:
			while true; do
				du -h myfile.zip;
				sleep 5;
			done
  
- scp:
	- General: scp <local file> <host>:<remote location>
		- e.g. localfile.txt a-mile-app-port-1.qa.octanner.net:./
	- Specify SSH user: -o "User=<USER-HERE>", e.g. "User=matt.hess@octanner.com"
		scp -o "User=<USER-HERE>@octanner.com" eclientlink2-21.06.01b-custom.war a-mile-app-port-1.qa.octanner.net:./
    
- type: 
	- finds a program: type <command>, e.g. type java

- lsof:
	- find the process using a port: lsof -i :<port>
		- e.g. lsof -i :8080
	- find ALL the ports used by a single pid: lsof -i -P | grep <pid>
		- e.g. lsof -i -P | grep 86859
    
- nl: number the lines in a file: nl <file>
	- The -s option is for formatting, e.g. nl -s ".,formatme, " <file> yields line numbers of the form "1.,formatme, <line1>", "2.,formatme, <line2>", etc.
	- format ALL lines (include blanks): -b a 
		- e.g.: nl -b a <file>
	- Only number lines matching expression: -p<expression>
		- e.g.: 
	- Start numbering at given number: -v<number>
		- e.g.: nl -v 100 <filename>
    
- sed: global string replacement: sed -i -e 's/<PATTERN>/<REPLACEMENT>/g' <filename>
	sed -i -e 's/);$/ /g' 1.sql
	- e.g. replace all end of line ); with ),: sed -i -e 's/);$/),/g' 2.sql
	- print to stdout instead of replacing file: remove the '-i' part, e.g. sed -e 's/PATTERN/REPLACE/g' hello.txt
  
- mkdir:
	- check if directory already exists, and if not, create path to it: mkdir -p <path>
		- e.g. mkdir -p /a/b/c/d if a and b both exist, c and d will both be created
    
- jot: print sequential or random chars to the screen? 
	- e.g. jot -c 128 0
  
- echo: 
	- use -n to not echo the newline
	- use -e to use backslash chars?
		- otherwise echo "\n" literally prints "\n", not outputs a new line
	- see https://www.tecmint.com/echo-command-in-linux/ for details
  
- run process in background: <command> &
	- e.g. echo "abc" &
  
- CRON STRINGS:
	- https://freeformatter.com/cron-expression-generator-quartz.html
	
- wget:
	- continue download: wget --continue https://example.com/linux-distro.iso
	- check short URL: wget --max-redirect 0 "https://bit.ly/2yDyS4T"
	
- curl:
	- data-binary upload: curl -X POST --data-binary "@<filename-here>" <url-here>
		- e.g.: curl -X PUT --data-binary "@image2.jpg" "https://mydomain.com/upload"
	- Another way to upload: cat <file> | curl -X PUT -v -H "Content-Type: <content-type>" --data-binary @- "uploadURL": "<url>"
		- e.g.: cat "Titillium-Light.otf" | curl -X PUT -v -H "Content-Type: font/otf" --data-binary @- "uploadURL": "https://fontproxy.io/0306342d-6d26-4f63-87bb-869af889b57d?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20211029T231906Z&X-Amz-SignedHeaders=content-type%3Bhost&X-Amz-Expires=300&X-Amz-Credential=AKIA4SVW6KK4RHD2ZBJS%2F20211029%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Signature=7f0dafff5d8e4360a984677cb5bc00a330cfc4227f7bf6bc673f8e80354184b0"
	
- hexdump: hexdump <file>

- du: du <directory> 
	- note: directory can be blank, i.e. `du`
	- -sh: show total disk usage of current dir (in human-friendly format)
	- -a: show disk usage of all files/folders in dir
	- -m: counts everything in megabyte blocks
	- exclusion: --exclude="*.txt"
	
- sleep:
	- sleep <num-seconds>
		- e.g. sleep 5
			- sleeps for 5 seconds
			- NOT milliseconds
			
- ln (symlinks): ln [-s] /path/to/original /path/to/link
	- Use -s for soft/standard
	- Soft links don't work anymore if the original file gets moved
